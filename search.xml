<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>非旋Treap讲解</title>
    <url>/2020/02/03/fhq-treap/</url>
    <content><![CDATA[<p>非旋 Treap，又称FHQ-Treap，是一种好写<del>又好吃</del>，常数小，可拓展性强的弱平衡的二叉搜索树。</p>
<a id="more"></a>
<p>FHQ-Treap 的讲解在其他地方也能找到，这里主要讲她的其他用法，比如——序列操作。</p>
<h2 id="例题一-文艺平衡树"><a href="#例题一-文艺平衡树" class="headerlink" title="例题一 文艺平衡树"></a>例题一 <a href="https://loj.ac/problem/105" target="_blank" rel="noopener">文艺平衡树</a></h2><p>我们来试试拿 FHQ-Treap 解决 Splay 模板题~</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个长度为 $n$ 的序列，初始值为 $(1,2,\cdots,n-1,n)$，你需要执行 $m$ 次操作，每次操作给定一个区间 $[l,r]$，你需要翻转这个区间。举个例子，序列 $(1,2,3,4,5)$ 的 $[2,5]$ 翻转后会变为：$(1,5,4,3,2)$。</p>
<p>$1\leqslant n,m\leqslant 10^5$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>翻转的时候用一种“翻转懒标记”的东西来翻转，标记下传的时候就交换一下左右儿子，每次翻转区间 $[l,r]$ 就将原区间分成 $[1,l)$，$[l,r]$，$(r, n]$ 三部分，然后将中间那部分标记一下，最后 merge 到一起。</p>
<p>时间复杂度期望 $\Theta((n+m)\log n)$，空间复杂度 $\Theta(n)$。</p>
<p>具体细节见代码部分。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type, <span class="keyword">int</span> SIZE = <span class="number">100000</span>, <span class="keyword">int</span> seed = <span class="number">19260817</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class fhq_treap &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	class node &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span> key, size, lchild, rchild; </span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// key是随机权值，size是子树大小，lchild,rchild是左右儿子编号。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		type data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 数据。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">bool</span> reverse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 区间翻转lazy tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125; tree[SIZE];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::mt19937 myrand; <span class="comment">// [1-3]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="comment">// 更新子树大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		tree[x].size = tree[tree[x].lchild].size + tree[tree[x].rchild].size +</span></pre></td></tr><tr><td class="code"><pre><span class="line">					   <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_down_reverse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (tree[x].reverse) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			tree[x].lchild ^= tree[x].rchild ^= </span></pre></td></tr><tr><td class="code"><pre><span class="line">							  tree[x].lchild ^= tree[x].rchild; <span class="comment">// swap [4]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (tree[x].lchild) &#123; <span class="comment">// 我们当然不想让tree[0]改来改去（虽然没有影响）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				tree[tree[x].lchild].reverse ^= <span class="number">1</span>; <span class="comment">// [5]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (tree[x].rchild) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				tree[tree[x].rchild].reverse ^= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			tree[x].reverse = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fhq_treap(<span class="keyword">void</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="function">mt19937 <span class="title">tmp</span><span class="params">(seed)</span></span>; <span class="comment">// 初始化种子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		myrand = tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="comment">// build一个结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		++count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tree[count].data = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tree[count].size = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tree[count].key = myrand(); <span class="comment">// 随机赋权值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123; <span class="comment">// 返回x,y的子树合并后根的编号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) &#123; <span class="comment">// 如果两棵树有空树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">return</span> x + y; <span class="comment">// 如果两棵树都是空树，返回空树，否则返回非空的那棵树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (tree[x].key &lt; tree[y].key) &#123; <span class="comment">// 如果x的随机权值比y小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			push_down_reverse(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			tree[x].rchild = merge(tree[x].rchild, y); <span class="comment">// y和x右子树合并</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			update_size(x); <span class="comment">// 更新x子树大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">return</span> x; <span class="comment">// 合并后x肯定为根</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">// 同上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			push_down_reverse(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			tree[y].lchild = merge(x, tree[y].lchild);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			update_size(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">return</span> y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 关于tuple的知识，你可以去 [6-7] 查看。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; split(<span class="keyword">const</span> <span class="keyword">int</span>&amp; root, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (root == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		push_down_reverse(root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (tree[tree[root].lchild].size &lt; k) &#123; <span class="comment">// 左子树大小不够</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">auto</span> oldres = split(tree[root].rchild,</span></pre></td></tr><tr><td class="code"><pre><span class="line">								k - tree[tree[root].lchild].size - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 后一个参数的意思是去掉左子树和根的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			tree[root].rchild = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(oldres); <span class="comment">// 更新右子树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			res = <span class="built_in">std</span>::make_tuple(root, <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(oldres));</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">// 左子树大小够</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">auto</span> oldres = split(tree[root].lchild, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			tree[root].lchild = <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(oldres);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			res = <span class="built_in">std</span>::make_tuple(<span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(oldres), root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		update_size(root); <span class="comment">// 更新子树大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; root)</span> </span>&#123; <span class="comment">// 中序遍历输出整棵树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (root == <span class="number">0</span>) &#123; <span class="comment">// 如果是空树，返回。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		push_down_reverse(root); <span class="comment">// 翻转懒标记下传</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		print(tree[root].lchild); <span class="comment">// 输出左子树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d "</span>, tree[root].data); <span class="comment">// 输出本身</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		print(tree[root].rchild); <span class="comment">// 输出右子树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; root)</span> </span>&#123; <span class="comment">// 翻转子树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		tree[root].reverse ^= <span class="number">1</span>; <span class="comment">// 标记一下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>; <span class="comment">// 搞定~</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">fhq_treap&lt;<span class="keyword">int</span>, <span class="number">100010</span>&gt; tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> n, m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> root = <span class="number">0</span>; <span class="comment">// 树根</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		root = tree.merge(root, tree.build(i)); <span class="comment">// 插入i</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span> revl, revr; <span class="comment">// 翻转区间左右端点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;revl, &amp;revr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">auto</span> tmp = tree.split(root, revl - <span class="number">1</span>); <span class="comment">// 拆分-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">auto</span> tmp2 = tree.split(<span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(tmp), revr - revl + <span class="number">1</span>); <span class="comment">// 拆分-2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		tree.reverse(<span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(tmp2)); <span class="comment">// 翻转</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		root = tree.merge(<span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(tmp), tree.merge(<span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(tmp2),</span></pre></td></tr><tr><td class="code"><pre><span class="line">													   <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(tmp2))); </span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 合并</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tree.print(root); <span class="comment">// 输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Tips:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// [1]: https://oi-wiki.org/misc/random/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// [2]: https://zh.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// [3]: https://en.wikipedia.org/wiki/Mersenne_twister</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// [4]: 第一次见这种写法，你可能会被吓到：a ^= b ^= a ^= b真的能交换a和b的值？</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		这里将阐述这种做法的正确性。我们假设x和y分别是两个bool变量，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		如果x ^= y ^= x ^= y能交换x和y的值，那我们对a和b的每一位拿出来做这个运算，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		也能交换这两位，于是a和b的每一位都交换了，所以a和b的值也交换了。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		我们枚举(x, y)的4种初始值(0, 0), (0, 1), (1, 0), (1, 1)，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		观察在x ^= y ^= x ^= y的每一步之后(x, y)的变化情况（注意^=是右结合的）：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		(0, 0) -&gt; (0, 0) -&gt; (0, 0) -&gt; (0, 0)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		(0, 1) -&gt; (1, 1) -&gt; (1, 0) -&gt; (1, 0)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		(1, 0) -&gt; (1, 0) -&gt; (1, 1) -&gt; (0, 1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		(1, 1) -&gt; (0, 1) -&gt; (0, 1) -&gt; (1, 1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		发现了吗？(x, y)经过操作之后一定会变为(y, x)。所以我们证明了该操作的正确性。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// [5]: 对于bool变量x，x ^= 1等价于x = !x。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//		你可以通过枚举x分别为true和false的情况来证明这个操作的正确性。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// [6]: https://zh.cppreference.com/w/cpp/header/tuple</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// [7]: https://zh.cppreference.com/w/cpp/utility/tuple</span></span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式游玩全攻略</title>
    <url>/2020/01/08/polynomial/</url>
    <content><![CDATA[<blockquote>
<p>多项式是一种非常好玩的东西，有无数种玩法，本文就是多项式这款休闲小游戏的<strong>全</strong>攻略。</p>
</blockquote>
<a id="more"></a>
<h2 id="多项式求值"><a href="#多项式求值" class="headerlink" title="多项式求值"></a>多项式求值</h2><p>给定一个多项式 $f(x)=\sum\limits_{i=0}^na_ix^i$，请求出 $f(b)$ 的值。</p>
<h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>最朴素的做法就是暴力计算每一项了吧~</p>
<p>这个算法的时间复杂度为 $\Theta(n^2)$，<strong>额外</strong>的空间复杂度为 $\Theta(1)$。</p>
<p>给一份伪代码：</p>
<script type="math/tex; mode=display">\begin{array}{ll}1&sum\gets0\\2&\mathbf{for}\text{ each } 0\leqslant i\leqslant n\\3&\qquad prod\gets1\\4&\qquad \mathbf{for}\text{ each }1\leqslant j\leqslant i\\5&\qquad\qquad prod\gets prod\times b\\6&\qquad sum\gets sum+prod\times a_i\end{array}</script><h3 id="保存幂值"><a href="#保存幂值" class="headerlink" title="保存幂值"></a>保存幂值</h3><p>这个做法时间复杂度为 $\Theta(n)$，<strong>额外</strong>空间复杂度为 $\Theta(1)$。</p>
<script type="math/tex; mode=display">\begin{array}{ll}1&sum\gets0\\2&pow\gets1\\3&\mathbf{for}\text{ each }0\leqslant i\leqslant n\\4&\quad sum\gets sum+a_i\times pow\\5&\quad pow\gets pow\times b\end{array}</script><h2 id="多项式加法"><a href="#多项式加法" class="headerlink" title="多项式加法"></a>多项式加法</h2><p>给定多项式函数 $f(x),g(x)$，请求出一多项式函数 $h(x)$ 使得 $h(x)=f(x)+g(x)$ 恒成立。</p>
<p>首先先将 $f(x),g(x)$ 中次数小的那个不断添加系数为 $0$ 的高次项使得两者次数相等（比如 $f(x)=x^2+x+2,g(x)=x+1$，则将 $g(x)$ 化为 $0x^2+x+1$）。令，最终 $f(x)$ 与 $g(x)$ 的次数为 $n$，于是 $f(x)=\sum\limits_{i=0}^na_ix^i$ 且 $g(x)=\sum\limits_{i=0}^nb_ix^i$，则</p>
<script type="math/tex; mode=display">\begin{aligned}h(x)&=f(x)+g(x)\\&=\sum\limits_{i=0}^na_ix^i+\sum\limits_{i=0}^nb_ix^i\\&=\sum\limits_{i=0}^n(a_i+b_i)x^i\end{aligned}</script><p>这个做法的时间复杂度为 $\Theta(n)$。</p>
<h2 id="多项式减法"><a href="#多项式减法" class="headerlink" title="多项式减法"></a>多项式减法</h2><p>给定多项式函数 $f(x),g(x)$，请求出一多项式函数 $h(x)$ 使得 $h(x)=f(x)-g(x)$ 恒成立。</p>
<p>解决方案同多项式加法。时间复杂度也为 $\Theta(n)$。</p>
<h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><p>给定多项式函数 $f(x),g(x)$，请求出一多项式函数 $h(x)$ 使得 $h(x)=f(x)g(x)$ 恒成立。</p>
<h3 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h3><p>直接用列竖式相乘。具体而言，若 $f(x)=\sum\limits_{j=0}^{n-1}a_jx^j,g(x)=\sum\limits_{j=0}^{n-1}b_jx^j$，则有 $h(x)=\sum\limits_{j=0}^{2n-2}\left(\sum\limits_{k=0}^ja_kb_{j-k}\right)x^j$。</p>
<p>时间复杂度 $\Theta(n^2)$。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>Möbius反演&amp;Dirichlet卷积学习笔记</title>
    <url>/2019/12/07/Mobius-inversion-for-beginner/</url>
    <content><![CDATA[<!--comment-->
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="先-一下大数学家"><a href="#先-一下大数学家" class="headerlink" title="先%一下大数学家"></a>先%一下大数学家</h3><p><a href="https://baike.baidu.com/item/%E5%A5%A5%E5%8F%A4%E6%96%AF%E7%89%B9%C2%B7%E8%B4%B9%E8%BF%AA%E5%8D%97%E5%BE%B7%C2%B7%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF" target="_blank" rel="noopener">August Ferdinand Möbius - 百度百科</a></p>
<p><a href="https://en.wikipedia.org/wiki/August_Ferdinand_M%C3%B6bius" target="_blank" rel="noopener">August Ferdinand Möbius - Wikipedia</a></p>
<p><a href="https://baike.baidu.com/item/%E7%BA%A6%E7%BF%B0%C2%B7%E5%BD%BC%E5%BE%97%C2%B7%E5%8F%A4%E6%96%AF%E5%A1%94%E5%A4%AB%C2%B7%E5%8B%92%E7%83%AD%E7%BA%B3%C2%B7%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7" target="_blank" rel="noopener">Johann Peter Gustav Lejeune Dirichlet - 百度百科</a></p>
<p><a href="https://en.wikipedia.org/wiki/Peter_Gustav_Lejeune_Dirichlet" target="_blank" rel="noopener">Johann Peter Gustav Lejeune Dirichlet - Wikipedia</a></p>
<h3 id="在本文可能会出现的记号"><a href="#在本文可能会出现的记号" class="headerlink" title="在本文可能会出现的记号"></a>在本文可能会出现的记号</h3><ul>
<li>$(a,b)$：$a$ 和 $b$ 的最大公约数，即 $\gcd(a,b)$</li>
<li>$a|b$：$a$ 整除 $b$</li>
<li>$\mathbb P$：素数集合</li>
<li>$\binom n m$：在 $n$ 个不同的元素内无序地选出 $m$ 个元素的方案数，为了方便起见，定义当 $n&lt;0$ 或 $m &lt; 0$ 或 $n &lt; m$ 时 $\binom n m=0$。有时候 $\binom n m$ 也记作 $\text C_n^m$。（注意 $n$ 和 $m$ 的位置对调了！）</li>
<li>$[\text P]$：若命题 $\text P$ 成立，则 $[\text P]=1$，否则 $[\text P]=0$。或者说， <script type="math/tex; mode=display">[\text P]=\begin{cases}1&\operatorname{if  \;P}\\0&\operatorname{otherwise}\end{cases}</script></li>
<li>$\omega(n)$：$n$ 的不同的质因子个数，特别地，$\omega(1)=0$</li>
<li>$\nu_p(n)$：$n$ 质因数分解后质数 $p$ 的幂次，即 $\nu_p(n)=\max\limits_{j}\left\{p^j|n\right\}$</li>
<li>$\Omega(n)$ ：$n$ 质因数分解后所有质数幂次之和，即 $\Omega(n)=\sum\limits_p\nu_p(n)$</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>数论函数（Arithmetic function）：定义域为 $\mathbb Z^+$ ，值域 $A\subset \mathbb C$ 的函数</li>
<li>积性函数（Multipicative function）：对于任意正整数 $a,b$，当 $\gcd(a,b)=1$ 时，满足 $f(ab)=f(a)f(b)$ 的一类数论函数</li>
<li>完全积性函数（Completely Multipicative function）：对于任意正整数 $a,b$，满足 $f(ab)=f(a)f(b)$ 的一类数论函数</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>$\sum$ 和 $\prod$ 如果不是在括号内部（比如 $\cdots(\sum\cdots)\cdots$），优先级最低。</li>
<li>在推式子的时候末尾可能会有一些注释，一般在式子的右边，用中文括号或英文括号括起来，譬如：<script type="math/tex; mode=display">\begin{aligned}f(x)&=x^2-1\\&=(x+1)(x-1)&\text{（平方差公式）}\end{aligned}</script></li>
</ul>
<h2 id="Mobius函数"><a href="#Mobius函数" class="headerlink" title="Möbius函数"></a>Möbius函数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Möbius函数，记作 $\mu(n)$，定义为：</p>
<script type="math/tex; mode=display">\mu(n)=\begin{cases}(-1)^{\omega(n)}&\nexists p\in\mathbb P:p^2|n\\0&\operatorname{otherwise}\end{cases}</script><p><strong>定理1-1</strong> $\mu(n)$ 是积性函数。</p>
<p><strong>证明</strong></p>
<blockquote>
<p>设正整数 $a,b$ 满足 $\gcd(a,b)=1$。</p>
<p>如果存在一个 $p$ 使得 $p^2|a$ 或 $p^2|b$，则 $\mu(a)=0$ 或 $\mu(b)=0$。<br>$\because p^2|a$ 或 $p^2|b$<br>$\therefore p^2|ab$<br>$\therefore \mu(ab)=0=\mu(a)\mu(b)$</p>
<p>如果不存在这样的 $p$，则：<br>$\begin{aligned}\mu(ab)&amp;=(-1)^{\omega(ab)}\\&amp;=(-1)^{\omega(a)+\omega(b)}\\&amp;=(-1)^{\omega(a)}(-1)^{\omega(b)}&amp;(\gcd(a,b)=1)\\&amp;=\mu(a)\mu(b)\end{aligned}$</p>
<p>证毕~</p>
</blockquote>
<p><strong>定理1-2</strong> $\mu(n)$ 不是完全积性函数。</p>
<p><strong>证明</strong></p>
<blockquote>
<p>$\because \mu(2\times2)=0\neq 1=\mu(2)\times\mu(2)$<br>$\therefore\mu(n)$ 不是完全积性函数。<br>证毕~</p>
</blockquote>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>定理2</strong> </p>
<script type="math/tex; mode=display">\sum\limits_{d|n}\mu(d)=\begin{cases}1&n=1\\0&n>1\end{cases}</script><p>也可以记作：</p>
<script type="math/tex; mode=display">\sum\limits_{d|n}\mu(d)=[n=1]</script><p><strong>证明</strong></p>
<blockquote>
<p>考虑 $n$ 和其因数 $d$ 的质因数分解：</p>
<script type="math/tex; mode=display">n=\prod\limits_{i=1}^{\omega(n)}p_i^{k_i}</script><script type="math/tex; mode=display">d=\prod\limits_{i=1}^{\omega(n)}p_i^{k_i'}\quad(k_i'\leqslant k_i)</script><p>因为当任何一个 $k_i’$ 取值 $&gt;1$ 时，$\mu(d)=0$，因此我们只考虑 $k_i’\leqslant 1$ 的情况。考虑枚举 $k_i’$ 为 $1$ 的个数，因为当 $k_i’$ 中有 $j$ 个为 $1$ 的 $d$ 有 $\binom {\omega(n)} j$ 个，并且 $\omega(d)=j$，又因为 $\binom n m=\binom {n-1}{m-1}+\binom {n-1}m$，因此有</p>
<script type="math/tex; mode=display">\begin{aligned}\sum\limits_{d|n}\mu(d)&=\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom{ \omega(n)}i\\&=\left(\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom {\omega(n)-1} {i - 1}\right)+\left(\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom {\omega(n)-1} i\right)\\&=(-1)^0\binom {\omega(n)-1} {0-1}+\left(\sum\limits_{i=1}^{\omega(n)}(-1)^i\binom {\omega(n)-1}{i-1}\right)+\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^i\binom {\omega(n)-1} i\right)+(-1)^{\omega(n)}\binom {\omega(n)-1}{\omega(n)}\\&=0+\left(\sum\limits_{i=1}^{\omega(n)}(-1)^i\binom {\omega(n)-1}{i-1}\right)+\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^i\binom {\omega(n)-1} i\right)+0\\&=\left(\sum\limits_{i=1}^{\omega(n)}(-1)^i\binom {\omega(n)-1}{i-1}\right)+\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^i\binom {\omega(n)-1} i\right)\\&=\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^{i+1}\binom {\omega(n)-1}i\right)+\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^i\binom {\omega(n)-1} i\right)\\&=\sum\limits_{i=0}^{\omega(n)-1}\left((-1)^i+(-1)^{i+1}\right)\binom {\omega(n)-1} i\\&=\sum\limits_{i=0}^{\omega(n)-1}0\binom {\omega(n)-1}i\\&=0\end{aligned}</script><p>那为什么当 $n=1$ 时 $\sum\limits_{d|n}\mu(d)=1$ 呢？<br>因为 $\binom n m = \binom {n-1}{m-1}+\binom{n-1}m$ 成立的一个必要条件为 $n^2+m^2\neq0$（显然 $\binom 0 0=1 \neq 0=\binom {-1}{-1} + \binom{-1}0$），而当 $n=1$ 时 $\begin{aligned}\sum\limits_{d|n}\mu(d)&amp;=\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom {\omega(i)}i\\&amp;=(-1)^0\binom00\end{aligned}$，而 $\binom00$ 是无法被分解为 $\binom {-1}{-1} + \binom{-1}0$ 的，从而该式当 $n=1$ 时不成立。</p>
<p>我们需要特殊处理 $n=1$ 的情况，这很容易解决，因为只有 $d=1$ 的时候才有 $d|n$，从而此时</p>
<script type="math/tex; mode=display">\begin{aligned}\sum\limits_{d|n}\mu(d)&=\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom {\omega(i)}i\\&=(-1)^0\binom00\\&=1\times1\\&=1\end{aligned}</script><p>综上，当 $n\neq1$ 时原式的值为 $0$，否则原式等于 $1$。故有</p>
<script type="math/tex; mode=display">\sum\limits_{d|n}\mu(d)=\begin{cases}1&n=1\\0&n>1\end{cases}</script><p>。证毕~</p>
</blockquote>
<h3 id="例1-完全平方数"><a href="#例1-完全平方数" class="headerlink" title="例1 完全平方数"></a>例1 完全平方数</h3><h4 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h4><ol>
<li><a href="https://vjudge.net/problem/HYSBZ-2440" target="_blank" rel="noopener">vjudge - bzoj</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2440" target="_blank" rel="noopener">bzoj</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2440" target="_blank" rel="noopener">lg</a></li>
<li><a href="http://hoj.free.idcfengye.com/problem/227" target="_blank" rel="noopener">hoj</a></li>
</ol>
<h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><blockquote>
<p>定义“无平方因子数”为质因数分解后所有质因数次数均为 $1$ 的数，即满足</p>
<script type="math/tex; mode=display">\prod\limits_{i=1}^{\omega(n)}\nu(p_i)=1</script><p>的 $n$ 值。</p>
<p>给你 $K$ 组询问，每组询问给定一个数 $k$，请你求出第 $k$ 小的无平方因子数。</p>
<p> 对于每组数据，有 $1\leqslant K\leqslant50$，且所有的 $k$ 都满足 $1\leqslant k\leqslant 10^5$。</p>
</blockquote>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>首先我们需要先求出 $n$ 以内有多少无平方因子数，这样子就可以二分答案惹</p>
<p>首先我们根据容斥原理<del>容易</del>得到：</p>
<script type="math/tex; mode=display">\begin{aligned}&n\text{以内的无平方因子数个数}\\=&n\text{以内每0个质数乘积的平方的倍数数量}\\-&n\text{以内每0个质数乘积的平方的倍数数量}\\+&n\text{以内每0个质数乘积的平方的倍数数量}\\-&\dots\end{aligned}</script><p><del>容易得到</del>正整数 $i$ 的平方的倍数数量前的符号为 $(-1)^{\omega (i)}=\mu(i)$。</p>
<p>我们又知道 $n$ 以内 $i^2$ 的倍数共有 $\left\lfloor\frac {n}{i^2}\right\rfloor$ 个，故 $n$ 以内的非平方因子数个数为：</p>
<script type="math/tex; mode=display">\sum\limits_{i=1}^{\left\lfloor\sqrt x\right\rfloor}\mu(i)\left\lfloor\dfrac n {i^2}\right\rfloor</script><p>预处理 $\mu(i)$ 的值，然后二分答案就可以惹~</p>
<p>每组数据时间复杂度为 $O(\sqrt k\log k)$</p>
<p>那怎么预处理 $\mu(i)$ 的值呢？</p>
<p>这里给出一个C++代码，其中 <code>mu(x)</code> 是一个宏定义，定义为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mu(n) mobius[n]</span></span></pre></td></tr></table></figure>
<p>而 <code>mobius</code> 数组是存储 $\mu(x)$ 的值的。</p>
<p>代码如下，注意它仅计算了 $[1,\text{MaxN})$ 里的所有的 $x$ 的 $\mu(x)$ 的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mu(<span class="number">1</span>) = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MaxN; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (!vst[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mu(i) = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			prm[++prm_cnt] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prm_cnt &amp;&amp; i * prm[j] &lt; MaxN; ++j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			vst[i * prm[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (i % prm[j] == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mu(i * prm[j]) = -mu(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxN 80009</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mobius[MaxN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prm[MaxN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vst[MaxN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prm_cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mu(n) mobius[n]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mu(<span class="number">1</span>) = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MaxN; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (!vst[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mu(i) = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			prm[++prm_cnt] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prm_cnt &amp;&amp; i * prm[j] &lt; MaxN; ++j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			vst[i * prm[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (i % prm[j] == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mu(i * prm[j]) = -mu(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>&amp; tmp)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="keyword">long</span> <span class="keyword">long</span>)i * i &lt;= tmp; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		res += mu(i) * (tmp / (i * i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>&amp; l, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>&amp; r, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (check(mid) &lt; k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> find(mid + <span class="number">1</span>, r, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> find(l, mid, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">signed</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	init();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>, r = <span class="number">8000000000l</span>l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (check(mid) &gt;= tmp) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				r = mid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019题解</title>
    <url>/2019/11/30/CSP2019-solution/</url>
    <content><![CDATA[<!--dd-->
<a id="more"></a>
<h1 id="CSP-J"><a href="#CSP-J" class="headerlink" title="CSP-J"></a>CSP-J</h1><h2 id="T1-数字游戏"><a href="#T1-数字游戏" class="headerlink" title="T1 数字游戏"></a>T1 数字游戏</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a><a href="https://www.luogu.com.cn/problem/P5660" target="_blank" rel="noopener">描述</a></h3><p>小K给小P发了一个$8$位的$01$字符串，现在小P想知道这里有多少个$1$。</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>输入一个字符，判断是否为<code>&#39;1&#39;</code>。如果为<code>&#39;1&#39;</code>则<code>++cnt;</code>。</p>
<h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">char</span> ch = getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ans += ch - <span class="string">'0'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>输入整数$x$，输出$x\mod9$。</p>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">signed</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d"</span>, a % <span class="number">9</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="T2-公交换乘"><a href="#T2-公交换乘" class="headerlink" title="T2 公交换乘"></a>T2 公交换乘</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>小轩乘坐了$n$次公共交通工具，给出每次交通工具的类型（公交车或地铁），还有上车时间，以及票价。坐车的时间忽略不计。如果他在$t$时刻乘坐了一辆票价为$x$的地铁，则若有一次公交车的乘坐时间为</p>
]]></content>
      <categories>
        <category>CSP2019</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Sperner定理</title>
    <url>/2019/11/30/Sperners-theorem/</url>
    <content><![CDATA[<h2 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h2><p>Sperner定理：对于任意一个包含$n$个元素的集合$U$，我们最多能选择$\dbinom n {\left\lfloor\frac {n} 2\right\rfloor}$个子集，使得这些子集中没有包含关系。<br><a id="more"></a></p>
<h2 id="定理证明"><a href="#定理证明" class="headerlink" title="定理证明"></a>定理证明</h2><h3 id="引理-Lubell–Yamamoto–Meshalkin不等式"><a href="#引理-Lubell–Yamamoto–Meshalkin不等式" class="headerlink" title="引理 Lubell–Yamamoto–Meshalkin不等式"></a>引理 Lubell–Yamamoto–Meshalkin不等式</h3><p>对于包含 $n$ 个元素的集合 $U$，令 $A$ 为一个由 $U$ 的子集组成的集合，使得 $\forall A_1, A_2 \in A$，$A_1 \subsetneq A_2$ 和 $A_1 \supsetneq A_2$ 均不成立。设 $a_k$ 表示 $A$ 中大小为 $k$ 的集合的个数，则有：</p>
<p>$\sum\limits_{k=0}^n \dfrac{a_k}{\binom n k}\leqslant 1$</p>
<p>证明：</p>
<blockquote>
<p>对于 $S\in U$，我们构造一个 $1\sim n$ 的排列 $\sigma$，使得对于 $i\in S,j\not\in S$，有 $\sigma_i &lt; \sigma_j$。</p>
<p>譬如，对于 $U=\{1, 2, 3, 4\},S=\{2, 4\}$，$\{\sigma_1, \sigma_2, \sigma_3, \sigma_4\}$有以下$4$种可能：</p>
<p>$\begin{aligned}\{2, 4, 1, 3\}\\<br>\{2, 4, 3, 1\}\\<br>\{4, 2, 1, 3\}\\<br>\{4, 2, 3, 1\}\end{aligned}$</p>
<p>如果 $S\subseteq S’$ ，则必定存在一个 $1\sim n$ 的排列 $\tau$，使得 $S$ 和 $S’$ 都能构造出 $\tau$。</p>
<p>证明：</p>
<blockquote>
<p>$\tau$ 的构造由三部分组成：$\{S\}, \{\complement_{S’}S\}, \{\complement_{U}S’\}$。证毕。</p>
</blockquote>
<p>还有命题：如果存在一个 $1\sim n$ 的排列 $\tau$，使得 $S$ 和 $S’$ 都能构造出 $\tau$，则必有 $S\subseteq S’$ 或 $S’\subseteq S$。</p>
<p>证明：</p>
<blockquote>
<p>首先 $S$ 和 $S’$ 一定都是 $\{\tau\}$ 的一个前缀，然后 $|S|&lt;|S’|\Leftrightarrow S \subsetneq S’$，$|S|=|S’|\Leftrightarrow S = S’$，$|S|&gt;|S’|\Leftrightarrow S’ \subsetneq S$。证毕。</p>
</blockquote>
<p>由 $A$ 的性质得，由 $A$ 内的元素所构造的排列两两不同。</p>
<p>因为集合 $S$ 能够构造出 $|S|!\left(n-|S|\right)!$ 个不同的排列，所以对于 $S\in A$ 的所有$S$能够构造出的不同的排列的个数为：</p>
<p>$\sum\limits_{S\in A} |S|!\left(n - |S|\right)!$</p>
<p>因为它们两两不同，又因为$1\sim n$的排列个数只有$n!$种，所以：</p>
<p>$\sum\limits_{S\in A} |S|!\left(n - |S|\right)! \leqslant n!\quad\cdots(1)$</p>
<p>将$S$按照$|S|$整理得：</p>
<p>$\sum\limits_{S\in A} |S|!\left(n - |S|\right)! = \sum\limits_{k = 0}^n a_k k!(n-k)!\quad\cdots(2)$</p>
<p>联立$(1),(2)$得：</p>
<p>$\sum\limits_{k = 0}^n a_k k!(n-k)! \leqslant n!$</p>
<p>将$n!$除过去：</p>
<p>$\sum\limits_{k = 0}^n \dfrac{a_k}{\binom n k} \leqslant 1$</p>
<p>证毕！</p>
</blockquote>
<h3 id="Sperner定理证明"><a href="#Sperner定理证明" class="headerlink" title="Sperner定理证明"></a>Sperner定理证明</h3><blockquote>
<p>令$S$为一个由$U$的子集组成的集合，使得$\forall S_1, S_2 \in S$，$S_1 \subsetneq S_2$和$S_1 \supsetneq S_2$均不成立。令$s_k$表示$S$中包含$k$个元素的集合的个数。</p>
<p>$\because \forall 0\leqslant k \leqslant n$，有$\binom n {\left\lfloor \frac n 2 \right\rfloor} \geqslant \binom n k$，</p>
<p>$\therefore \dfrac {s_k} {\binom n {\left\lfloor \frac n 2 \right\rfloor}} \leqslant \dfrac {s_k} {\binom n k}$。</p>
<p>$\therefore \sum\limits_{k=0}^n\dfrac {s_k} {\binom n {\left\lfloor \frac n 2 \right\rfloor}\leqslant \sum\limits_{k=0}^n\dfrac {s_k} {\binom n k}}\leqslant 1 $。</p>
<p>$\therefore \sum\limits_{k=0}^n\dfrac {s_k} {\binom n {\left\lfloor \frac n 2 \right\rfloor}} \leqslant 1$。</p>
<p>$\therefore |S| = \sum\limits_{k = 0}^n s_k \leqslant \binom n {\left\lfloor \frac n 2 \right\rfloor}$。</p>
<p>证毕！</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019总结</title>
    <url>/2019/11/25/CSP2019-summary/</url>
    <content><![CDATA[<p>一个初二OIer的总结~</p>
<a id="more"></a>
<h2 id="CSP-J"><a href="#CSP-J" class="headerlink" title="CSP-J"></a>CSP-J</h2><h3 id="T1-数字游戏"><a href="#T1-数字游戏" class="headerlink" title="T1 数字游戏"></a>T1 数字游戏</h3><p>这道题是真的水题，要不是今年PJ难度降低了不少，不然觉得连做PJD1T1的难度都没有。。。</p>
<p>相信不用怎么讲的了，因为CCF保证输入文件没有任何多余行末空格或多余文件末换行，不用考虑奇怪的情况，比如假设CCF不保证，那么下面的代码就很容易被Hack：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">signed</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">char</span> ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">while</span> (~(ch = <span class="built_in">std</span>::getchar())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tot += ch - <span class="string">'0'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="T2-公交换乘"><a href="#T2-公交换乘" class="headerlink" title="T2 公交换乘"></a>T2 公交换乘</h3><p>实话说我对这道题究竟该怎么实现纠结了很久……本来想皮一下用<code>std::set</code>的，但是最后还是用了队列实现。。</p>
<p>不知道考场怎么想的，为了遍历队列，我手写了一个长达41行的队列……应该是过了吧</p>
<h3 id="T3-纪念品"><a href="#T3-纪念品" class="headerlink" title="T3 纪念品"></a>T3 纪念品</h3><p>成功爆炸……</p>
<p>大致思路是分段乱搞……如果<code>t==1</code>，那当然直接输出<code>m</code>啦，然后其他的点乱打，成功只拿到了<code>t==1</code>的点。</p>
<p>考场上本来应该能想到背包的……</p>
<h3 id="T4-加工零件"><a href="#T4-加工零件" class="headerlink" title="T4 加工零件"></a>T4 加工零件</h3><p>考试的时候当然想到了从1开始求最短路的方法，但是苦于不知道怎么处理奇偶的情况，然后在lg上40分……</p>
<p>个人觉得奇偶还挺好想的？</p>
<h2 id="CSP-S"><a href="#CSP-S" class="headerlink" title="CSP-S"></a>CSP-S</h2><h3 id="D1T1-格雷码"><a href="#D1T1-格雷码" class="headerlink" title="D1T1 格雷码"></a>D1T1 格雷码</h3><p>祖宗我总算见到你了！！！</p>
<p>显然我没有开<code>unsigned long long</code>，但是就算开了<code>unsigned long long</code>也不能保证万无一失，比如这是我考场的代码，就算<code>long long</code>全部改成<code>unsigned long long</code>也无济于事：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">code</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;m)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">putchar</span>(m + <span class="string">'0'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (m &lt; (<span class="number">1l</span>l &lt;&lt; (n - <span class="number">1</span>))) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">putchar</span>(<span class="string">'0'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		code(n - <span class="number">1</span>, m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">putchar</span>(<span class="string">'1'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		code(n - <span class="number">1</span>, (<span class="number">1l</span>l &lt;&lt; n) - <span class="number">1l</span>l - m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>为什么呢？因为<code>1ull &lt;&lt; 64</code>会爆<code>unsigned long long</code>。</p>
<h3 id="D1T2-括号树"><a href="#D1T2-括号树" class="headerlink" title="D1T2 括号树"></a>D1T2 括号树</h3><p>直接打链的情况，调了会之后在lg上75分。</p>
<p>对于每个结点，一路往上走，直到到根结点，然后记得维护前缀和，然后对于i和i的一个祖宗j，如果<code>S[i] &gt; S[j]</code>，那么直接不合法，跳出。否则如果<code>S[i] == S[j]</code>，<code>++ans[i]</code>。</p>
<h3 id="D1T3-树上的数"><a href="#D1T3-树上的数" class="headerlink" title="D1T3 树上的数"></a>D1T3 树上的数</h3><p><del>样例都没过，还想拿分？</del></p>
<p>在lg上成功爆0，大致讲讲思路吧</p>
<p>时间复杂度$O(n!)$，对于$1\sim n$的每个排列（使用<code>&lt;algorithm&gt;</code>里的<code>std::next_permutation</code>），都计算一遍当前字典序，然后看看最小的是什么。</p>
<h3 id="D2T1-Emiya家今天的饭"><a href="#D2T1-Emiya家今天的饭" class="headerlink" title="D2T1 Emiya家今天的饭"></a>D2T1 Emiya家今天的饭</h3><p>直接爆搜。lg上能跑32分，大概拿满爆搜分了吧……</p>
<p>按照烹饪方法枚举。</p>
<p>考场上居然忘记剪枝了，表示崩溃……</p>
<h3 id="D2T2-划分"><a href="#D2T2-划分" class="headerlink" title="D2T2 划分"></a>D2T2 划分</h3><p>真的不知道怎么打了。。。随便想了一种解法，看似没有问题，过了样例，然而只拿了8分的高分……</p>
<h3 id="D2T3-树的重心"><a href="#D2T3-树的重心" class="headerlink" title="D2T3 树的重心"></a>D2T3 树的重心</h3><p>连暴力都木有，直接一个<code>std::freopen</code>和<code>std::fclose</code>结束了程序。。。</p>
<h2 id="估分"><a href="#估分" class="headerlink" title="估分"></a>估分</h2><p>CSP-J 250~290</p>
<p>CSP-S 160~190</p>
]]></content>
      <categories>
        <category>CSP2019</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019合辑</title>
    <url>/2019/11/20/CSP2019/</url>
    <content><![CDATA[<ol>
<li><a href="/2019/11/18/CSP2019-diary">CSP2019游记</a></li>
<li><a href="/2019/11/25/CSP2019-summary">CSP2019总结</a></li>
<li><a href="/2019/11/30/CSP2019-solution">CSP2019题解</a></li>
</ol>
]]></content>
      <categories>
        <category>CSP2019</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019游记</title>
    <url>/2019/11/18/CSP2019-diary/</url>
    <content><![CDATA[<p>一个蒟蒻OIer的游记……</p>
<a id="more"></a>
<p>前置信息：本人广东初二学生。</p>
<h2 id="2019-10-19-CSP-S-Round-1"><a href="#2019-10-19-CSP-S-Round-1" class="headerlink" title="2019.10.19 CSP-S Round 1"></a>2019.10.19 CSP-S Round 1</h2><p>前面的选择题严重影响了我对整张试卷难度的预测。。。然后车牌那道题我做了几百遍也没做出选项内答案，在写了十多分钟然而无果后，摔笔，瞎蒙，下一道。（2333）</p>
<p>距离考试还有15分钟的时候，下课铃响彻了整个二中，把考生都吓到了，然后铃声响完以后一个男声响起：“距离考试结束还有15分钟”……</p>
<p>然后由于低估了题目难度以及数量，导致留给最后一道题的时候只有五分钟了……半蒙半做地搞完了</p>
<p>出来的时候拿着A卷答案去和别人B卷答案对，感觉要凉</p>
<p>最后？77分，GD分数线71分</p>
<p>lemon拿到了70.5分，不幸与复赛无缘，荣获年度最佳人品称号！</p>
<p>后来分数线降到了68分。可是还是有一位神仙同学$\sin$无缘复赛。</p>
<h2 id="2019-10-19-CSP-J-Round-1"><a href="#2019-10-19-CSP-J-Round-1" class="headerlink" title="2019.10.19 CSP-J Round 1"></a>2019.10.19 CSP-J Round 1</h2><p>本来由于上午的惨痛教训，我打算尽快完成试卷。后来想想还是算了，慢慢地品味试卷。</p>
<p>品味的时候看到上午那道阉割版车牌题，差点笑出了声</p>
<p>考试快结束的时候又是那个男声。。。</p>
<p>最后考了83分。至于分数线，那并不重要。（反正过了就对了hhhh）</p>
<h2 id="2019-11-16-CSP-S-Round-2-Day-1"><a href="#2019-11-16-CSP-S-Round-2-Day-1" class="headerlink" title="2019.11.16 CSP-S Round 2 Day 1"></a>2019.11.16 CSP-S Round 2 Day 1</h2><p>本来以为会是<code>JianGuo70Nian</code>之类的，没想到是个……</p>
<p>首先是D1T1，显然这种题就是SB题，但是我一开始很SB地写了<code>int</code>……样例#3成功爆炸，于是重新看看代码……改成<code>long long</code>后成功过了样例#3，幸甚至哉，我在代码某一行写了一段注释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// long time no see, my great great great great great great great great grandfather!</span></span></pre></td></tr></table></figure>
<p>出考场时：“蛤？要<code>unsigned long long</code>？？！”<strong>见祖宗啦——</strong></p>
<p>D1T2我就直接打了50分$O(n^2)$暴力，然后出考场的时候——</p>
<blockquote>
<p>啊？T2要异或和？我直接加起来了<br>——又是lemon</p>
</blockquote>
<p>2333……</p>
<p>D1T3没调出暴力，心态炸了</p>
<p>预估分数：$95+50+0=145$，见祖宗花了我$5$分……</p>
<p>话说我一开始一直在用垃圾Dev-C++，因为Notepad++在我眼里是最烂的编辑器，而Vim和Emacs明显不是我这种蒟蒻能够用的……考了一个半小时之后在桌面上看到了Sublime Text 3……</p>
<p>坐我右边那位大佬超爱Dev-C++的调试功能，只见一条红条和一条蓝条在屏幕上迅速移动……</p>
<h2 id="2019-11-16-CSP-J-Round-2"><a href="#2019-11-16-CSP-J-Round-2" class="headerlink" title="2019.11.16 CSP-J Round 2"></a>2019.11.16 CSP-J Round 2</h2><p>考试前为了放松身心，在二中楼梯上颓了好久的Rolling Sky。。。</p>
<p>有一个初一的陌生同学（他：我真的不是小学生！！！）一直盯着我玩，而且嘴里吐出了很多他们本来应该在下个学期生物课上才会学到的奇妙词语……</p>
<p>考试了，我看了看桌面，没有Sublime Text 3。找了半天没找到游戏，唉……</p>
<p>坐我左边的是一位大佬，他根本不知道压缩包可以压缩，于是他想要测样例的时候就先把文件拖出来，然后输密码，然后用写字板打开，从上往下划（不知道<code>Ctrl/Command+A</code>吗），然后丢到控制台里。</p>
<p>到T2的最后一个样例的时候，他本来打算故技重施的，结果尝试了一两分钟后发现还要好久……我以为他要全选的，结果并不！他把写字板调成一个屏幕能显示四五十页的，然后再次选择。。。</p>
<p>控制台那里粘贴了好久……</p>
<p>最后他把他自己的文件夹扔到了压缩包里，然后在文件夹内有一个叫<code>***的基本资料</code>的文件夹，里面是什么呢？一个把<code>CSP-J.pdf</code>更名为<code>***.pdf</code>的文件，然后他用记事本打开，在前面加了自己的信息。</p>
<p>做T3的时候我傻了，明明想到了正解但是因为只会证t==2时正确性，于是……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 骗分1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 骗分2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 正解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我冤啊……</p>
<p>（话说T1的样例#2还是<code>title.in</code>和<code>title.out</code>来着？不知道有多少人知道……</p>
<h2 id="2019-11-17-CSP-S-Round-2-Day-2"><a href="#2019-11-17-CSP-S-Round-2-Day-2" class="headerlink" title="2019.11.17 CSP-S Round 2 Day 2"></a>2019.11.17 CSP-S Round 2 Day 2</h2><p>看到D2T1，果断打暴力。</p>
<p>看到D2T2，犹豫了许久还是打了暴力。</p>
<p>看到D2T3，发现突然忘记树的重心怎么打了……于是懵逼……</p>
<p>反正还有一个小时，掏出桌面小程序，打开数字华容道……</p>
<p>颓了五局然后发现！右边的右边的右边的lemon还在打！我顿时觉得T3好像有分可夺，于是瞄了一眼……<strong>这链的情况不是在嘲讽人吗？？！</strong></p>
<p>最后因为只有三十分钟了，成功没有调出来……</p>
]]></content>
      <categories>
        <category>CSP2019</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的lambda表达式</title>
    <url>/2019/02/03/lambda-expression-in-cpp/</url>
    <content><![CDATA[<!--comment-->
<a id="more"></a>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>建议遇到不理解的地方多多利用 <a href="https://oi-wiki.org/" target="_blank" rel="noopener">OI-wiki</a>、<a href="https://zh.cppreference.com/w/" target="_blank" rel="noopener">中文 C++ Reference</a>、<a href="https://wikipedia.org/" target="_blank" rel="noopener">维基百科</a> 等资料，或者联系笔者。</p>
<p>本文略长，且部分内容在日常 OI/ACM 中鲜有用到，不过，对于 C++ 这种语言来讲，学习是永远的归宿。</p>
<h2 id="为什么要使用-lambda-表达式？"><a href="#为什么要使用-lambda-表达式？" class="headerlink" title="为什么要使用 lambda 表达式？"></a>为什么要使用 lambda 表达式？</h2><p>假设你现在要实现一个程序，其中有一个维护函数，维护函数中需要排序一个 <code>node</code> 数组：</p>
<p>假设你已经定义了 <code>node::operator&lt;</code> 另做他用，所以你在 <code>std::sort</code> 的时候得要新建一个 <code>cmp</code> 函数。</p>
<p>看看这种写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 很多变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; arr[<span class="number">100</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 很多代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node&amp; a, <span class="keyword">const</span> node&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 比较函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::sort(arr, arr + <span class="number">100</span>, cmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个时候，你发现 <code>cmp</code> 函数仅在一条语句中使用过，万一以后又有一个语句需要另一个 <code>cmp</code> 函数呢？来一个 <code>cmp2</code> ？这样子，当其他人看你的代码的时候，会感到很困惑不解<del>，这人怎么定义这么多 <code>cmp</code></del>。就算是你自己维护自己的代码，也会觉得很烦，因为 <code>cmp</code> 函数与语句 <code>std::sort(arr, arr + 100, cmp);</code> 距离太远了，维护难度很大。</p>
<p>就没有什么办法了吗？</p>
<p>有一种叫 <strong>匿名函数</strong> （anonymous function）的东西，可以不把函数与函数名“绑定”在一起，而是使用一种表达式来表示一个函数，这个表达式的值即为一个匿名函数，我们只需要 <code>auto func = /* 这个表达式 */</code> 便可以将 <code>func</code> 调用多次。如果像上文一样，函数只用定义一次，那我们就直接 <code>std::sort(arr, arr + 100, /* 这个表达式 */);</code> 即可。</p>
<p>C++ 标准将其称为 lambda 表达式（lambda expression）。</p>
<p>称其为 <strong>lambda</strong> 表达式实际上是源自 20 世纪 30 年代 Alonzo Church 提出的 <a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener"><strong>lambda calculus</strong></a>（也作 $\lambda$-calculus）的。匿名函数与计算机设计语言相结合最早是在 1958 年，LISP 语言，而 C++ 也在 C++11 标准中加入了原生 lambda 表达式。</p>
<h2 id="lambda-表达式的基础用法"><a href="#lambda-表达式的基础用法" class="headerlink" title="lambda 表达式的基础用法"></a>lambda 表达式的基础用法</h2><h3 id="从最最基础的-lambda-表达式讲起"><a href="#从最最基础的-lambda-表达式讲起" class="headerlink" title="从最最基础的 lambda 表达式讲起"></a>从最最基础的 lambda 表达式讲起</h3><p>我们先从下面这份判断奇偶性的 lambda 表达式看起：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>;&#125;</span></pre></td></tr></table></figure>
<p>我们来分析一下这个 lambda 表达式的各个元素：</p>
<ol>
<li><code>[]</code>：捕获；</li>
<li><code>(int x)</code>：形式参数列表；</li>
<li><code>-&gt;</code>：标识符；</li>
<li><code>bool</code>：类型声明；</li>
<li><code>{return x % 2 == 0;}</code>：函数体。</li>
</ol>
<p>除去我们暂时不知道的“捕获”和一个大家都见过的标识符以外，其他的东西和普通函数的定义并无二样。</p>
<p>我们可以理解为，这个表达式返回一个函数，这个函数的形参列表是 <code>(int x)</code>，返回值类型是 <code>bool</code>，函数体是 <code>{return x % 2 == 0;}</code>。至于普通函数里的函数名，那只是个标识罢了。我们来看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bool is_even(int x) -&gt; bool &#123;return x % 2 == 0;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">is_even(a); <span class="comment">// 这段代码是和下面等价的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x) &#123;<span class="keyword">return</span> x % <span class="number">2</span>;&#125;(a);</span></pre></td></tr></table></figure>
<p>当然，你也可以定义一个变量来储存 lambda 表达式的值，以便多次调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> is_even = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">is_even(<span class="number">2</span>); <span class="comment">// return true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">is_even(<span class="number">3</span>); <span class="comment">// return false</span></span></pre></td></tr></table></figure>
<h3 id="来看看捕获"><a href="#来看看捕获" class="headerlink" title="来看看捕获"></a>来看看捕获</h3><p>我们现在来讲讲这个捕获。何为捕获呢？一个 lambda 表达式可能会使用到外部的变量，这个时候我们就需要使用捕获（capture）来捕获这些变量。</p>
<p>捕获由一个可选的默认捕获符，以及任意多个捕获符组成：</p>
<p>我们先看看这两个常用的捕获符格式：</p>
<ul>
<li><code>&amp;var</code>：<strong>引用</strong>传递变量 <code>var</code> ，以供函数体使用，函数体可以改变 <code>var</code> 的值。</li>
<li><code>var</code>：<strong>按值</strong>传递变量 <code>var</code>。</li>
</ul>
<p>如果你还是不理解，你可以参考这份代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[]() -&gt; <span class="keyword">void</span> &#123;x = <span class="number">2</span>;&#125;(); <span class="comment">// 编译错误，lambda 表达式内不能使用 x（没有捕获，没有形参）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x) -&gt; <span class="keyword">void</span> &#123;x = <span class="number">3</span>;&#125;(x); <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d"</span>, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 编译通过，但是并没有改变 lambda 表达式外部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                     </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> x = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">	[]() -&gt; <span class="keyword">void</span> &#123;x = <span class="number">3</span>;&#125;(); <span class="comment">// 编译错误，lambda 表达式内不能使用 x（没有捕获，没有形参）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [](<span class="keyword">int</span> x) -&gt; <span class="keyword">void</span> &#123;x = <span class="number">3</span>;&#125;(x); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x); <span class="comment">// 输出 2，因为 x 只是被当作参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
</search>
