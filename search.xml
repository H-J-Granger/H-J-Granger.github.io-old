<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多项式详解I——多项式基础</title>
    <url>/2020/01/08/polynomial-i/</url>
    <content><![CDATA[<h2 id="多项式求值"><a href="#多项式求值" class="headerlink" title="多项式求值"></a>多项式求值</h2><p>给定一个多项式 $f(x)=\sum\limits_{i=0}^na_ix^i$，请求出 $f(b)$ 的值。</p>
<h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>最朴素的做法就是暴力计算每一项了吧~</p>
<p>这个算法的时间复杂度为 $\Theta(n^2)$，<strong>额外</strong>的空间复杂度为 $\Theta(1)$。</p>
<p>给一份伪代码：</p>
<script type="math/tex; mode=display">\begin{array}{ll}1&sum\gets0\\2&\mathbf{for}\text{ each } 0\leqslant i\leqslant n\\3&\qquad prod\gets1\\4&\qquad \mathbf{for}\text{ each }1\leqslant j\leqslant i\\5&\qquad\qquad prod\gets prod\times b\\6&\qquad sum\gets sum+prod\times a_i\end{array}</script><h3 id="保存幂值"><a href="#保存幂值" class="headerlink" title="保存幂值"></a>保存幂值</h3><p>这个做法时间复杂度为 $\Theta(n)$，<strong>额外</strong>空间复杂度为 $\Theta(1)$。</p>
<script type="math/tex; mode=display">\begin{array}{ll}1&sum\gets0\\2&pow\gets1\\3&\mathbf{for}\text{ each }0\leqslant i\leqslant n\\4&\quad sum\gets sum+a_i\times pow\\5&\quad pow\gets pow\times b\end{array}</script><h2 id="多项式加法"><a href="#多项式加法" class="headerlink" title="多项式加法"></a>多项式加法</h2><p>给定多项式函数 $f(x),g(x)$，请求出一多项式函数 $h(x)$ 使得 $h(x)=f(x)+g(x)$ 恒成立。</p>
<p>首先先将 $f(x),g(x)$ 中次数小的那个不断添加系数为 $0$ 的高次项使得两者次数相等（比如 $f(x)=x^2+x+2,g(x)=x+1$，则将 $g(x)$ 化为 $0x^2+x+1$）。令，最终 $f(x)$ 与 $g(x)$ 的次数为 $n$，于是 $f(x)=\sum\limits_{i=0}^na_ix^i$ 且 $g(x)=\sum\limits_{i=0}^nb_ix^i$，则</p>
<script type="math/tex; mode=display">\begin{aligned}h(x)&=f(x)+g(x)\\&=\sum\limits_{i=0}^na_ix^i+\sum\limits_{i=0}^nb_ix^i\\&=\sum\limits_{i=0}^n(a_i+b_i)x^i\end{aligned}</script><p>这个做法的时间复杂度为 $\Theta(n)$。</p>
<h2 id="多项式减法"><a href="#多项式减法" class="headerlink" title="多项式减法"></a>多项式减法</h2><p>给定多项式函数 $f(x),g(x)$，请求出一多项式函数 $h(x)$ 使得 $h(x)=f(x)-g(x)$ 恒成立。</p>
<p>解决方案同多项式加法。时间复杂度也为 $\Theta(n)$。</p>
]]></content>
      <categories>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>Möbius反演&amp;Dirichlet卷积学习笔记</title>
    <url>/2019/12/07/Mobius-inversion-for-beginner/</url>
    <content><![CDATA[<!--comment-->
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="先-一下大数学家"><a href="#先-一下大数学家" class="headerlink" title="先%一下大数学家"></a>先%一下大数学家</h3><p><a href="https://baike.baidu.com/item/%E5%A5%A5%E5%8F%A4%E6%96%AF%E7%89%B9%C2%B7%E8%B4%B9%E8%BF%AA%E5%8D%97%E5%BE%B7%C2%B7%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF" target="_blank" rel="noopener">August Ferdinand Möbius - 百度百科</a></p>
<p><a href="https://en.wikipedia.org/wiki/August_Ferdinand_M%C3%B6bius" target="_blank" rel="noopener">August Ferdinand Möbius - Wikipedia</a></p>
<p><a href="https://baike.baidu.com/item/%E7%BA%A6%E7%BF%B0%C2%B7%E5%BD%BC%E5%BE%97%C2%B7%E5%8F%A4%E6%96%AF%E5%A1%94%E5%A4%AB%C2%B7%E5%8B%92%E7%83%AD%E7%BA%B3%C2%B7%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7" target="_blank" rel="noopener">Johann Peter Gustav Lejeune Dirichlet - 百度百科</a></p>
<p><a href="https://en.wikipedia.org/wiki/Peter_Gustav_Lejeune_Dirichlet" target="_blank" rel="noopener">Johann Peter Gustav Lejeune Dirichlet - Wikipedia</a></p>
<h3 id="在本文可能会出现的记号"><a href="#在本文可能会出现的记号" class="headerlink" title="在本文可能会出现的记号"></a>在本文可能会出现的记号</h3><ul>
<li>$(a,b)$：$a$ 和 $b$ 的最大公约数，即 $\gcd(a,b)$</li>
<li>$a|b$：$a$ 整除 $b$</li>
<li>$\mathbb P$：素数集合</li>
<li>$\binom n m$：在 $n$ 个不同的元素内无序地选出 $m$ 个元素的方案数，为了方便起见，定义当 $n&lt;0$ 或 $m &lt; 0$ 或 $n &lt; m$ 时 $\binom n m=0$。有时候 $\binom n m$ 也记作 $\text C_n^m$。（注意 $n$ 和 $m$ 的位置对调了！）</li>
<li>$[\text P]$：若命题 $\text P$ 成立，则 $[\text P]=1$，否则 $[\text P]=0$。或者说， <script type="math/tex; mode=display">[\text P]=\begin{cases}1&\operatorname{if  \;P}\\0&\operatorname{otherwise}\end{cases}</script></li>
<li>$\omega(n)$：$n$ 的不同的质因子个数，特别地，$\omega(1)=0$</li>
<li>$\nu_p(n)$：$n$ 质因数分解后质数 $p$ 的幂次，即 $\nu_p(n)=\max\limits_{j}\left\{p^j|n\right\}$</li>
<li>$\Omega(n)$ ：$n$ 质因数分解后所有质数幂次之和，即 $\Omega(n)=\sum\limits_p\nu_p(n)$</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>数论函数（Arithmetic function）：定义域为 $\mathbb Z^+$ ，值域 $A\subset \mathbb C$ 的函数</li>
<li>积性函数（Multipicative function）：对于任意正整数 $a,b$，当 $\gcd(a,b)=1$ 时，满足 $f(ab)=f(a)f(b)$ 的一类数论函数</li>
<li>完全积性函数（Completely Multipicative function）：对于任意正整数 $a,b$，满足 $f(ab)=f(a)f(b)$ 的一类数论函数</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>$\sum$ 和 $\prod$ 如果不是在括号内部（比如 $\cdots(\sum\cdots)\cdots$），优先级最低。</li>
<li>在推式子的时候末尾可能会有一些注释，一般在式子的右边，用中文括号或英文括号括起来，譬如：<script type="math/tex; mode=display">\begin{aligned}f(x)&=x^2-1\\&=(x+1)(x-1)&\text{（平方差公式）}\end{aligned}</script></li>
</ul>
<h2 id="Mobius函数"><a href="#Mobius函数" class="headerlink" title="Möbius函数"></a>Möbius函数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Möbius函数，记作 $\mu(n)$，定义为：</p>
<script type="math/tex; mode=display">\mu(n)=\begin{cases}(-1)^{\omega(n)}&\nexists p\in\mathbb P:p^2|n\\0&\operatorname{otherwise}\end{cases}</script><p><strong>定理1-1</strong> $\mu(n)$ 是积性函数。</p>
<p><strong>证明</strong></p>
<blockquote>
<p>设正整数 $a,b$ 满足 $\gcd(a,b)=1$。</p>
<p>如果存在一个 $p$ 使得 $p^2|a$ 或 $p^2|b$，则 $\mu(a)=0$ 或 $\mu(b)=0$。<br>$\because p^2|a$ 或 $p^2|b$<br>$\therefore p^2|ab$<br>$\therefore \mu(ab)=0=\mu(a)\mu(b)$</p>
<p>如果不存在这样的 $p$，则：<br>$\begin{aligned}\mu(ab)&amp;=(-1)^{\omega(ab)}\\&amp;=(-1)^{\omega(a)+\omega(b)}\\&amp;=(-1)^{\omega(a)}(-1)^{\omega(b)}&amp;(\gcd(a,b)=1)\\&amp;=\mu(a)\mu(b)\end{aligned}$</p>
<p>证毕~</p>
</blockquote>
<p><strong>定理1-2</strong> $\mu(n)$ 不是完全积性函数。</p>
<p><strong>证明</strong></p>
<blockquote>
<p>$\because \mu(2\times2)=0\neq 1=\mu(2)\times\mu(2)$<br>$\therefore\mu(n)$ 不是完全积性函数。<br>证毕~</p>
</blockquote>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>定理2</strong> </p>
<script type="math/tex; mode=display">\sum\limits_{d|n}\mu(d)=\begin{cases}1&n=1\\0&n>1\end{cases}</script><p>也可以记作：</p>
<script type="math/tex; mode=display">\sum\limits_{d|n}\mu(d)=[n=1]</script><p><strong>证明</strong></p>
<blockquote>
<p>考虑 $n$ 和其因数 $d$ 的质因数分解：</p>
<script type="math/tex; mode=display">n=\prod\limits_{i=1}^{\omega(n)}p_i^{k_i}</script><script type="math/tex; mode=display">d=\prod\limits_{i=1}^{\omega(n)}p_i^{k_i'}\quad(k_i'\leqslant k_i)</script><p>因为当任何一个 $k_i’$ 取值 $&gt;1$ 时，$\mu(d)=0$，因此我们只考虑 $k_i’\leqslant 1$ 的情况。考虑枚举 $k_i’$ 为 $1$ 的个数，因为当 $k_i’$ 中有 $j$ 个为 $1$ 的 $d$ 有 $\binom {\omega(n)} j$ 个，并且 $\omega(d)=j$，又因为 $\binom n m=\binom {n-1}{m-1}+\binom {n-1}m$，因此有</p>
<script type="math/tex; mode=display">\begin{aligned}\sum\limits_{d|n}\mu(d)&=\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom{ \omega(n)}i\\&=\left(\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom {\omega(n)-1} {i - 1}\right)+\left(\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom {\omega(n)-1} i\right)\\&=(-1)^0\binom {\omega(n)-1} {0-1}+\left(\sum\limits_{i=1}^{\omega(n)}(-1)^i\binom {\omega(n)-1}{i-1}\right)+\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^i\binom {\omega(n)-1} i\right)+(-1)^{\omega(n)}\binom {\omega(n)-1}{\omega(n)}\\&=0+\left(\sum\limits_{i=1}^{\omega(n)}(-1)^i\binom {\omega(n)-1}{i-1}\right)+\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^i\binom {\omega(n)-1} i\right)+0\\&=\left(\sum\limits_{i=1}^{\omega(n)}(-1)^i\binom {\omega(n)-1}{i-1}\right)+\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^i\binom {\omega(n)-1} i\right)\\&=\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^{i+1}\binom {\omega(n)-1}i\right)+\left(\sum\limits_{i=0}^{\omega(n)-1}(-1)^i\binom {\omega(n)-1} i\right)\\&=\sum\limits_{i=0}^{\omega(n)-1}\left((-1)^i+(-1)^{i+1}\right)\binom {\omega(n)-1} i\\&=\sum\limits_{i=0}^{\omega(n)-1}0\binom {\omega(n)-1}i\\&=0\end{aligned}</script><p>那为什么当 $n=1$ 时 $\sum\limits_{d|n}\mu(d)=1$ 呢？<br>因为 $\binom n m = \binom {n-1}{m-1}+\binom{n-1}m$ 成立的一个必要条件为 $n^2+m^2\neq0$（显然 $\binom 0 0=1 \neq 0=\binom {-1}{-1} + \binom{-1}0$），而当 $n=1$ 时 $\begin{aligned}\sum\limits_{d|n}\mu(d)&amp;=\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom {\omega(i)}i\\&amp;=(-1)^0\binom00\end{aligned}$，而 $\binom00$ 是无法被分解为 $\binom {-1}{-1} + \binom{-1}0$ 的，从而该式当 $n=1$ 时不成立。</p>
<p>我们需要特殊处理 $n=1$ 的情况，这很容易解决，因为只有 $d=1$ 的时候才有 $d|n$，从而此时</p>
<script type="math/tex; mode=display">\begin{aligned}\sum\limits_{d|n}\mu(d)&=\sum\limits_{i=0}^{\omega(n)}(-1)^i\binom {\omega(i)}i\\&=(-1)^0\binom00\\&=1\times1\\&=1\end{aligned}</script><p>综上，当 $n\neq1$ 时原式的值为 $0$，否则原式等于 $1$。故有</p>
<script type="math/tex; mode=display">\sum\limits_{d|n}\mu(d)=\begin{cases}1&n=1\\0&n>1\end{cases}</script><p>。证毕~</p>
</blockquote>
<h3 id="例1-完全平方数"><a href="#例1-完全平方数" class="headerlink" title="例1 完全平方数"></a>例1 完全平方数</h3><h4 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h4><ol>
<li><a href="https://vjudge.net/problem/HYSBZ-2440" target="_blank" rel="noopener">vjudge - bzoj</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2440" target="_blank" rel="noopener">bzoj</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2440" target="_blank" rel="noopener">lg</a></li>
<li><a href="http://hoj.free.idcfengye.com/problem/227" target="_blank" rel="noopener">hoj</a></li>
</ol>
<h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><blockquote>
<p>定义“无平方因子数”为质因数分解后所有质因数次数均为 $1$ 的数，即满足</p>
<script type="math/tex; mode=display">\prod\limits_{i=1}^{\omega(n)}\nu(p_i)=1</script><p>的 $n$ 值。</p>
<p>给你 $K$ 组询问，每组询问给定一个数 $k$，请你求出第 $k$ 小的无平方因子数。</p>
<p> 对于每组数据，有 $1\leqslant K\leqslant50$，且所有的 $k$ 都满足 $1\leqslant k\leqslant 10^5$。</p>
</blockquote>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>首先我们需要先求出 $n$ 以内有多少无平方因子数，这样子就可以二分答案惹</p>
<p>首先我们根据容斥原理<del>容易</del>得到：</p>
<script type="math/tex; mode=display">\begin{aligned}&n\text{以内的无平方因子数个数}\\=&n\text{以内每0个质数乘积的平方的倍数数量}\\-&n\text{以内每0个质数乘积的平方的倍数数量}\\+&n\text{以内每0个质数乘积的平方的倍数数量}\\-&\dots\end{aligned}</script><p><del>容易得到</del>正整数 $i$ 的平方的倍数数量前的符号为 $(-1)^{\omega (i)}=\mu(i)$。</p>
<p>我们又知道 $n$ 以内 $i^2$ 的倍数共有 $\left\lfloor\frac {n}{i^2}\right\rfloor$ 个，故 $n$ 以内的非平方因子数个数为：</p>
<script type="math/tex; mode=display">\sum\limits_{i=1}^{\left\lfloor\sqrt x\right\rfloor}\mu(i)\left\lfloor\dfrac n {i^2}\right\rfloor</script><p>预处理 $\mu(i)$ 的值，然后二分答案就可以惹~</p>
<p>每组数据时间复杂度为 $O(\sqrt k\log k)$</p>
<p>那怎么预处理 $\mu(i)$ 的值呢？</p>
<p>这里给出一个C++代码，其中 <code>mu(x)</code> 是一个宏定义，定义为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mu(n) mobius[n]</span></span></pre></td></tr></table></figure>
<p>而 <code>mobius</code> 数组是存储 $\mu(x)$ 的值的。</p>
<p>代码如下，注意它仅计算了 $[1,\text{MaxN})$ 里的所有的 $x$ 的 $\mu(x)$ 的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mu(<span class="number">1</span>) = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MaxN; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (!vst[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mu(i) = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			prm[++prm_cnt] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prm_cnt &amp;&amp; i * prm[j] &lt; MaxN; ++j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			vst[i * prm[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (i % prm[j] == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mu(i * prm[j]) = -mu(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxN 80009</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mobius[MaxN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prm[MaxN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vst[MaxN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prm_cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mu(n) mobius[n]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mu(<span class="number">1</span>) = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MaxN; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (!vst[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mu(i) = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			prm[++prm_cnt] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prm_cnt &amp;&amp; i * prm[j] &lt; MaxN; ++j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			vst[i * prm[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (i % prm[j] == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			mu(i * prm[j]) = -mu(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>&amp; tmp)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="keyword">long</span> <span class="keyword">long</span>)i * i &lt;= tmp; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		res += mu(i) * (tmp / (i * i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>&amp; l, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>&amp; r, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (check(mid) &lt; k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> find(mid + <span class="number">1</span>, r, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> find(l, mid, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">signed</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	init();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>, r = <span class="number">8000000000l</span>l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (check(mid) &gt;= tmp) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				r = mid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019题解</title>
    <url>/2019/11/30/CSP2019-solution/</url>
    <content><![CDATA[<!--dd-->
<a id="more"></a>
<h1 id="CSP-J"><a href="#CSP-J" class="headerlink" title="CSP-J"></a>CSP-J</h1><h2 id="T1-数字游戏"><a href="#T1-数字游戏" class="headerlink" title="T1 数字游戏"></a>T1 数字游戏</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a><a href="https://www.luogu.com.cn/problem/P5660" target="_blank" rel="noopener">描述</a></h3><p>小K给小P发了一个$8$位的$01$字符串，现在小P想知道这里有多少个$1$。</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>输入一个字符，判断是否为<code>&#39;1&#39;</code>。如果为<code>&#39;1&#39;</code>则<code>++cnt;</code>。</p>
<h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">char</span> ch = getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ans += ch - <span class="string">'0'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>输入整数$x$，输出$x\mod9$。</p>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">signed</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d"</span>, a % <span class="number">9</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="T2-公交换乘"><a href="#T2-公交换乘" class="headerlink" title="T2 公交换乘"></a>T2 公交换乘</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>小轩乘坐了$n$次公共交通工具，给出每次交通工具的类型（公交车或地铁），还有上车时间，以及票价。坐车的时间忽略不计。如果他在$t$时刻乘坐了一辆票价为$x$的地铁，则若有一次公交车的乘坐时间为</p>
]]></content>
      <categories>
        <category>CSP2019</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Sperner定理</title>
    <url>/2019/11/30/Sperners-theorem/</url>
    <content><![CDATA[<h2 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h2><p>Sperner定理：对于任意一个包含$n$个元素的集合$U$，我们最多能选择$\dbinom n {\left\lfloor\frac {n} 2\right\rfloor}$个子集，使得这些子集中没有包含关系。<br><a id="more"></a></p>
<h2 id="定理证明"><a href="#定理证明" class="headerlink" title="定理证明"></a>定理证明</h2><h3 id="引理-Lubell–Yamamoto–Meshalkin不等式"><a href="#引理-Lubell–Yamamoto–Meshalkin不等式" class="headerlink" title="引理 Lubell–Yamamoto–Meshalkin不等式"></a>引理 Lubell–Yamamoto–Meshalkin不等式</h3><p>对于包含 $n$ 个元素的集合 $U$，令 $A$ 为一个由 $U$ 的子集组成的集合，使得 $\forall A_1, A_2 \in A$，$A_1 \subsetneq A_2$ 和 $A_1 \supsetneq A_2$ 均不成立。设 $a_k$ 表示 $A$ 中大小为 $k$ 的集合的个数，则有：</p>
<p>$\sum\limits_{k=0}^n \dfrac{a_k}{\binom n k}\leqslant 1$</p>
<p>证明：</p>
<blockquote>
<p>对于 $S\in U$，我们构造一个 $1\sim n$ 的排列 $\sigma$，使得对于 $i\in S,j\not\in S$，有 $\sigma_i &lt; \sigma_j$。</p>
<p>譬如，对于 $U=\{1, 2, 3, 4\},S=\{2, 4\}$，$\{\sigma_1, \sigma_2, \sigma_3, \sigma_4\}$有以下$4$种可能：</p>
<p>$\begin{aligned}\{2, 4, 1, 3\}\\<br>\{2, 4, 3, 1\}\\<br>\{4, 2, 1, 3\}\\<br>\{4, 2, 3, 1\}\end{aligned}$</p>
<p>如果 $S\subseteq S’$ ，则必定存在一个 $1\sim n$ 的排列 $\tau$，使得 $S$ 和 $S’$ 都能构造出 $\tau$。</p>
<p>证明：</p>
<blockquote>
<p>$\tau$ 的构造由三部分组成：$\{S\}, \{\complement_{S’}S\}, \{\complement_{U}S’\}$。证毕。</p>
</blockquote>
<p>还有命题：如果存在一个 $1\sim n$ 的排列 $\tau$，使得 $S$ 和 $S’$ 都能构造出 $\tau$，则必有 $S\subseteq S’$ 或 $S’\subseteq S$。</p>
<p>证明：</p>
<blockquote>
<p>首先 $S$ 和 $S’$ 一定都是 $\{\tau\}$ 的一个前缀，然后 $|S|&lt;|S’|\Leftrightarrow S \subsetneq S’$，$|S|=|S’|\Leftrightarrow S = S’$，$|S|&gt;|S’|\Leftrightarrow S’ \subsetneq S$。证毕。</p>
</blockquote>
<p>由 $A$ 的性质得，由 $A$ 内的元素所构造的排列两两不同。</p>
<p>因为集合 $S$ 能够构造出 $|S|!\left(n-|S|\right)!$ 个不同的排列，所以对于 $S\in A$ 的所有$S$能够构造出的不同的排列的个数为：</p>
<p>$\sum\limits_{S\in A} |S|!\left(n - |S|\right)!$</p>
<p>因为它们两两不同，又因为$1\sim n$的排列个数只有$n!$种，所以：</p>
<p>$\sum\limits_{S\in A} |S|!\left(n - |S|\right)! \leqslant n!\quad\cdots(1)$</p>
<p>将$S$按照$|S|$整理得：</p>
<p>$\sum\limits_{S\in A} |S|!\left(n - |S|\right)! = \sum\limits_{k = 0}^n a_k k!(n-k)!\quad\cdots(2)$</p>
<p>联立$(1),(2)$得：</p>
<p>$\sum\limits_{k = 0}^n a_k k!(n-k)! \leqslant n!$</p>
<p>将$n!$除过去：</p>
<p>$\sum\limits_{k = 0}^n \dfrac{a_k}{\binom n k} \leqslant 1$</p>
<p>证毕！</p>
</blockquote>
<h3 id="Sperner定理证明"><a href="#Sperner定理证明" class="headerlink" title="Sperner定理证明"></a>Sperner定理证明</h3><blockquote>
<p>令$S$为一个由$U$的子集组成的集合，使得$\forall S_1, S_2 \in S$，$S_1 \subsetneq S_2$和$S_1 \supsetneq S_2$均不成立。令$s_k$表示$S$中包含$k$个元素的集合的个数。</p>
<p>$\because \forall 0\leqslant k \leqslant n$，有$\binom n {\left\lfloor \frac n 2 \right\rfloor} \geqslant \binom n k$，</p>
<p>$\therefore \dfrac {s_k} {\binom n {\left\lfloor \frac n 2 \right\rfloor}} \leqslant \dfrac {s_k} {\binom n k}$。</p>
<p>$\therefore \sum\limits_{k=0}^n\dfrac {s_k} {\binom n {\left\lfloor \frac n 2 \right\rfloor}\leqslant \sum\limits_{k=0}^n\dfrac {s_k} {\binom n k}}\leqslant 1 $。</p>
<p>$\therefore \sum\limits_{k=0}^n\dfrac {s_k} {\binom n {\left\lfloor \frac n 2 \right\rfloor}} \leqslant 1$。</p>
<p>$\therefore |S| = \sum\limits_{k = 0}^n s_k \leqslant \binom n {\left\lfloor \frac n 2 \right\rfloor}$。</p>
<p>证毕！</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019总结</title>
    <url>/2019/11/25/CSP2019-summary/</url>
    <content><![CDATA[<p>一个初二OIer的总结~</p>
<a id="more"></a>
<h2 id="CSP-J"><a href="#CSP-J" class="headerlink" title="CSP-J"></a>CSP-J</h2><h3 id="T1-数字游戏"><a href="#T1-数字游戏" class="headerlink" title="T1 数字游戏"></a>T1 数字游戏</h3><p>这道题是真的水题，要不是今年PJ难度降低了不少，不然觉得连做PJD1T1的难度都没有。。。</p>
<p>相信不用怎么讲的了，因为CCF保证输入文件没有任何多余行末空格或多余文件末换行，不用考虑奇怪的情况，比如假设CCF不保证，那么下面的代码就很容易被Hack：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">signed</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">char</span> ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">while</span> (~(ch = <span class="built_in">std</span>::getchar())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tot += ch - <span class="string">'0'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="T2-公交换乘"><a href="#T2-公交换乘" class="headerlink" title="T2 公交换乘"></a>T2 公交换乘</h3><p>实话说我对这道题究竟该怎么实现纠结了很久……本来想皮一下用<code>std::set</code>的，但是最后还是用了队列实现。。</p>
<p>不知道考场怎么想的，为了遍历队列，我手写了一个长达41行的队列……应该是过了吧</p>
<h3 id="T3-纪念品"><a href="#T3-纪念品" class="headerlink" title="T3 纪念品"></a>T3 纪念品</h3><p>成功爆炸……</p>
<p>大致思路是分段乱搞……如果<code>t==1</code>，那当然直接输出<code>m</code>啦，然后其他的点乱打，成功只拿到了<code>t==1</code>的点。</p>
<p>考场上本来应该能想到背包的……</p>
<h3 id="T4-加工零件"><a href="#T4-加工零件" class="headerlink" title="T4 加工零件"></a>T4 加工零件</h3><p>考试的时候当然想到了从1开始求最短路的方法，但是苦于不知道怎么处理奇偶的情况，然后在lg上40分……</p>
<p>个人觉得奇偶还挺好想的？</p>
<h2 id="CSP-S"><a href="#CSP-S" class="headerlink" title="CSP-S"></a>CSP-S</h2><h3 id="D1T1-格雷码"><a href="#D1T1-格雷码" class="headerlink" title="D1T1 格雷码"></a>D1T1 格雷码</h3><p>祖宗我总算见到你了！！！</p>
<p>显然我没有开<code>unsigned long long</code>，但是就算开了<code>unsigned long long</code>也不能保证万无一失，比如这是我考场的代码，就算<code>long long</code>全部改成<code>unsigned long long</code>也无济于事：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">code</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;m)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">putchar</span>(m + <span class="string">'0'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (m &lt; (<span class="number">1l</span>l &lt;&lt; (n - <span class="number">1</span>))) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">putchar</span>(<span class="string">'0'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		code(n - <span class="number">1</span>, m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">std</span>::<span class="built_in">putchar</span>(<span class="string">'1'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		code(n - <span class="number">1</span>, (<span class="number">1l</span>l &lt;&lt; n) - <span class="number">1l</span>l - m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>为什么呢？因为<code>1ull &lt;&lt; 64</code>会爆<code>unsigned long long</code>。</p>
<h3 id="D1T2-括号树"><a href="#D1T2-括号树" class="headerlink" title="D1T2 括号树"></a>D1T2 括号树</h3><p>直接打链的情况，调了会之后在lg上75分。</p>
<p>对于每个结点，一路往上走，直到到根结点，然后记得维护前缀和，然后对于i和i的一个祖宗j，如果<code>S[i] &gt; S[j]</code>，那么直接不合法，跳出。否则如果<code>S[i] == S[j]</code>，<code>++ans[i]</code>。</p>
<h3 id="D1T3-树上的数"><a href="#D1T3-树上的数" class="headerlink" title="D1T3 树上的数"></a>D1T3 树上的数</h3><p><del>样例都没过，还想拿分？</del></p>
<p>在lg上成功爆0，大致讲讲思路吧</p>
<p>时间复杂度$O(n!)$，对于$1\sim n$的每个排列（使用<code>&lt;algorithm&gt;</code>里的<code>std::next_permutation</code>），都计算一遍当前字典序，然后看看最小的是什么。</p>
<h3 id="D2T1-Emiya家今天的饭"><a href="#D2T1-Emiya家今天的饭" class="headerlink" title="D2T1 Emiya家今天的饭"></a>D2T1 Emiya家今天的饭</h3><p>直接爆搜。lg上能跑32分，大概拿满爆搜分了吧……</p>
<p>按照烹饪方法枚举。</p>
<p>考场上居然忘记剪枝了，表示崩溃……</p>
<h3 id="D2T2-划分"><a href="#D2T2-划分" class="headerlink" title="D2T2 划分"></a>D2T2 划分</h3><p>真的不知道怎么打了。。。随便想了一种解法，看似没有问题，过了样例，然而只拿了8分的高分……</p>
<h3 id="D2T3-树的重心"><a href="#D2T3-树的重心" class="headerlink" title="D2T3 树的重心"></a>D2T3 树的重心</h3><p>连暴力都木有，直接一个<code>std::freopen</code>和<code>std::fclose</code>结束了程序。。。</p>
<h2 id="估分"><a href="#估分" class="headerlink" title="估分"></a>估分</h2><p>CSP-J 250~290</p>
<p>CSP-S 160~190</p>
]]></content>
      <categories>
        <category>CSP2019</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019合辑</title>
    <url>/2019/11/20/CSP2019/</url>
    <content><![CDATA[<ol>
<li><a href="/2019/11/18/CSP2019-diary">CSP2019游记</a></li>
<li><a href="/2019/11/25/CSP2019-summary">CSP2019总结</a></li>
<li><a href="/2019/11/30/CSP2019-solution">CSP2019题解</a></li>
</ol>
]]></content>
      <categories>
        <category>CSP2019</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019游记</title>
    <url>/2019/11/18/CSP2019-diary/</url>
    <content><![CDATA[<p>一个蒟蒻OIer的游记……</p>
<a id="more"></a>
<p>前置信息：本人广东初二学生。</p>
<h2 id="2019-10-19-CSP-S-Round-1"><a href="#2019-10-19-CSP-S-Round-1" class="headerlink" title="2019.10.19 CSP-S Round 1"></a>2019.10.19 CSP-S Round 1</h2><p>前面的选择题严重影响了我对整张试卷难度的预测。。。然后车牌那道题我做了几百遍也没做出选项内答案，在写了十多分钟然而无果后，摔笔，瞎蒙，下一道。（2333）</p>
<p>距离考试还有15分钟的时候，下课铃响彻了整个二中，把考生都吓到了，然后铃声响完以后一个男声响起：“距离考试结束还有15分钟”……</p>
<p>然后由于低估了题目难度以及数量，导致留给最后一道题的时候只有五分钟了……半蒙半做地搞完了</p>
<p>出来的时候拿着A卷答案去和别人B卷答案对，感觉要凉</p>
<p>最后？77分，GD分数线71分</p>
<p>lemon拿到了70.5分，不幸与复赛无缘，荣获年度最佳人品称号！</p>
<p>后来分数线降到了68分。可是还是有一位神仙同学$\sin$无缘复赛。</p>
<h2 id="2019-10-19-CSP-J-Round-1"><a href="#2019-10-19-CSP-J-Round-1" class="headerlink" title="2019.10.19 CSP-J Round 1"></a>2019.10.19 CSP-J Round 1</h2><p>本来由于上午的惨痛教训，我打算尽快完成试卷。后来想想还是算了，慢慢地品味试卷。</p>
<p>品味的时候看到上午那道阉割版车牌题，差点笑出了声</p>
<p>考试快结束的时候又是那个男声。。。</p>
<p>最后考了83分。至于分数线，那并不重要。（反正过了就对了hhhh）</p>
<h2 id="2019-11-16-CSP-S-Round-2-Day-1"><a href="#2019-11-16-CSP-S-Round-2-Day-1" class="headerlink" title="2019.11.16 CSP-S Round 2 Day 1"></a>2019.11.16 CSP-S Round 2 Day 1</h2><p>本来以为会是<code>JianGuo70Nian</code>之类的，没想到是个……</p>
<p>首先是D1T1，显然这种题就是SB题，但是我一开始很SB地写了<code>int</code>……样例#3成功爆炸，于是重新看看代码……改成<code>long long</code>后成功过了样例#3，幸甚至哉，我在代码某一行写了一段注释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// long time no see, my great great great great great great great great grandfather!</span></span></pre></td></tr></table></figure>
<p>出考场时：“蛤？要<code>unsigned long long</code>？？！”<strong>见祖宗啦——</strong></p>
<p>D1T2我就直接打了50分$O(n^2)$暴力，然后出考场的时候——</p>
<blockquote>
<p>啊？T2要异或和？我直接加起来了<br>——又是lemon</p>
</blockquote>
<p>2333……</p>
<p>D1T3没调出暴力，心态炸了</p>
<p>预估分数：$95+50+0=145$，见祖宗花了我$5$分……</p>
<p>话说我一开始一直在用垃圾Dev-C++，因为Notepad++在我眼里是最烂的编辑器，而Vim和Emacs明显不是我这种蒟蒻能够用的……考了一个半小时之后在桌面上看到了Sublime Text 3……</p>
<p>坐我右边那位大佬超爱Dev-C++的调试功能，只见一条红条和一条蓝条在屏幕上迅速移动……</p>
<h2 id="2019-11-16-CSP-J-Round-2"><a href="#2019-11-16-CSP-J-Round-2" class="headerlink" title="2019.11.16 CSP-J Round 2"></a>2019.11.16 CSP-J Round 2</h2><p>考试前为了放松身心，在二中楼梯上颓了好久的Rolling Sky。。。</p>
<p>有一个初一的陌生同学（他：我真的不是小学生！！！）一直盯着我玩，而且嘴里吐出了很多他们本来应该在下个学期生物课上才会学到的奇妙词语……</p>
<p>考试了，我看了看桌面，没有Sublime Text 3。找了半天没找到游戏，唉……</p>
<p>坐我左边的是一位大佬，他根本不知道压缩包可以压缩，于是他想要测样例的时候就先把文件拖出来，然后输密码，然后用写字板打开，从上往下划（不知道<code>Ctrl/Command+A</code>吗），然后丢到控制台里。</p>
<p>到T2的最后一个样例的时候，他本来打算故技重施的，结果尝试了一两分钟后发现还要好久……我以为他要全选的，结果并不！他把写字板调成一个屏幕能显示四五十页的，然后再次选择。。。</p>
<p>控制台那里粘贴了好久……</p>
<p>最后他把他自己的文件夹扔到了压缩包里，然后在文件夹内有一个叫<code>***的基本资料</code>的文件夹，里面是什么呢？一个把<code>CSP-J.pdf</code>更名为<code>***.pdf</code>的文件，然后他用记事本打开，在前面加了自己的信息。</p>
<p>做T3的时候我傻了，明明想到了正解但是因为只会证t==2时正确性，于是……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 骗分1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 骗分2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 正解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我冤啊……</p>
<p>（话说T1的样例#2还是<code>title.in</code>和<code>title.out</code>来着？不知道有多少人知道……</p>
<h2 id="2019-11-17-CSP-S-Round-2-Day-2"><a href="#2019-11-17-CSP-S-Round-2-Day-2" class="headerlink" title="2019.11.17 CSP-S Round 2 Day 2"></a>2019.11.17 CSP-S Round 2 Day 2</h2><p>看到D2T1，果断打暴力。</p>
<p>看到D2T2，犹豫了许久还是打了暴力。</p>
<p>看到D2T3，发现突然忘记树的重心怎么打了……于是懵逼……</p>
<p>反正还有一个小时，掏出桌面小程序，打开数字华容道……</p>
<p>颓了五局然后发现！右边的右边的右边的lemon还在打！我顿时觉得T3好像有分可夺，于是瞄了一眼……<strong>这链的情况不是在嘲讽人吗？？！</strong></p>
<p>最后因为只有三十分钟了，成功没有调出来……</p>
]]></content>
      <categories>
        <category>CSP2019</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>OI</tag>
      </tags>
  </entry>
</search>
